#!/usr/bin/env tsx

/**
 * Session Creation CLI Tool
 * Creates new presentation sessions with unique IDs and optional database provisioning
 *
 * Usage:
 *   pnpm session:create --name "Workshop Day 1" --id workshop-day-1
 *   pnpm session:create --name "AI Training" (auto-generates ID)
 *   pnpm session:create --name "Demo" --db (also creates database)
 */

import * as fs from 'fs'
import * as path from 'path'
import { execSync } from 'child_process'

// Colors for output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
}

function printInfo(msg: string) {
  console.log(`${colors.blue}[INFO]${colors.reset} ${msg}`)
}

function printSuccess(msg: string) {
  console.log(`${colors.green}[SUCCESS]${colors.reset} ${msg}`)
}

function printWarning(msg: string) {
  console.log(`${colors.yellow}[WARNING]${colors.reset} ${msg}`)
}

function printError(msg: string) {
  console.log(`${colors.red}[ERROR]${colors.reset} ${msg}`)
}

// Parse command line arguments
interface CliArgs {
  name?: string
  id?: string
  description?: string
  db?: boolean
  help?: boolean
}

function parseArgs(): CliArgs {
  const args = process.argv.slice(2)
  const result: CliArgs = {}

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]

    if (arg === '--help' || arg === '-h') {
      result.help = true
    } else if (arg === '--name' || arg === '-n') {
      result.name = args[++i]
    } else if (arg.startsWith('--name=')) {
      result.name = arg.split('=')[1]
    } else if (arg === '--id') {
      result.id = args[++i]
    } else if (arg.startsWith('--id=')) {
      result.id = arg.split('=')[1]
    } else if (arg === '--description' || arg === '-d') {
      result.description = args[++i]
    } else if (arg.startsWith('--description=')) {
      result.description = arg.split('=')[1]
    } else if (arg === '--db') {
      result.db = true
    }
  }

  return result
}

function printHelp() {
  console.log(`
Session Creation CLI Tool

Creates a new presentation session with a unique ID and optional database provisioning.

Usage:
  pnpm session:create [options]

Options:
  --name, -n <name>         Session name (required)
  --id <id>                 Custom session ID (optional, auto-generated if not provided)
  --description, -d <desc>  Session description (optional)
  --db                      Also create/initialize D1 database
  --help, -h                Show this help message

Examples:
  pnpm session:create --name "Workshop Day 1"
  pnpm session:create --name "AI Training" --id ai-training-2024
  pnpm session:create --name "Demo Session" --description "Demo for stakeholders" --db

Output:
  Creates/updates config/session.ts with session configuration
  Optionally initializes D1 database with session name
`)
}

function generateSessionId(name: string): string {
  const timestamp = Date.now()
  const slug = name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 20)
  const random = Math.random().toString(36).substring(2, 6)
  return `${slug}-${timestamp.toString(36)}-${random}`
}

function validateSessionId(id: string): boolean {
  // Must be at least 3 characters, alphanumeric with hyphens/underscores
  const pattern = /^[a-zA-Z0-9][a-zA-Z0-9_-]{2,}$/
  return pattern.test(id)
}

function createSessionConfig(
  sessionId: string,
  sessionName: string,
  description?: string
): string {
  const config = `/**
 * Session Configuration
 * Auto-generated by cli/create-session.ts
 *
 * Session: ${sessionName}
 * Created: ${new Date().toISOString()}
 */

export interface SessionConfig {
  sessionId: string
  sessionName: string
  description?: string
  createdAt: string
  presentationTitle: string
  databaseName?: string
}

function getSessionConfigFromEnv(): SessionConfig {
  const sessionId =
    process.env.NEXT_PUBLIC_SESSION_ID ||
    process.env.SESSION_ID ||
    '${sessionId}'

  const sessionName =
    process.env.NEXT_PUBLIC_SESSION_NAME ||
    process.env.SESSION_NAME ||
    '${sessionName}'

  const description =
    process.env.NEXT_PUBLIC_SESSION_DESCRIPTION ||
    process.env.SESSION_DESCRIPTION ||
    ${description ? `'${description}'` : 'undefined'}

  const presentationTitle =
    process.env.NEXT_PUBLIC_PRESENTATION_TITLE ||
    process.env.PRESENTATION_TITLE ||
    '${sessionName}'

  const databaseName = process.env.D1_DATABASE_NAME || 'presentation-feedback'

  return {
    sessionId,
    sessionName,
    description,
    createdAt: '${new Date().toISOString()}',
    presentationTitle,
    databaseName,
  }
}

export const sessionConfig: SessionConfig = getSessionConfigFromEnv()

export function createSessionConfig(
  overrides: Partial<SessionConfig>
): SessionConfig {
  return {
    ...sessionConfig,
    ...overrides,
  }
}

export function generateSessionId(prefix: string = 'session'): string {
  const timestamp = Date.now()
  const random = Math.random().toString(36).substring(2, 11)
  return \`\${prefix}-\${timestamp}-\${random}\`
}
`
  return config
}

async function main() {
  const args = parseArgs()

  if (args.help) {
    printHelp()
    process.exit(0)
  }

  if (!args.name) {
    printError('Session name is required. Use --name "Session Name"')
    printInfo('Run with --help for usage information')
    process.exit(1)
  }

  // Generate or validate session ID
  let sessionId = args.id || generateSessionId(args.name)

  if (args.id && !validateSessionId(args.id)) {
    printError(`Invalid session ID: ${args.id}`)
    printInfo('Session ID must be at least 3 characters, starting with alphanumeric')
    process.exit(1)
  }

  console.log('')
  console.log('===========================================')
  console.log('   Session Creation')
  console.log('===========================================')
  console.log('')

  printInfo(`Session Name: ${args.name}`)
  printInfo(`Session ID: ${sessionId}`)
  if (args.description) {
    printInfo(`Description: ${args.description}`)
  }
  console.log('')

  // Generate session config
  const configContent = createSessionConfig(
    sessionId,
    args.name,
    args.description
  )

  // Write to config/session.ts
  const configPath = path.join(process.cwd(), 'config', 'session.ts')

  // Backup existing config if it exists
  if (fs.existsSync(configPath)) {
    const backupPath = configPath + '.backup'
    fs.copyFileSync(configPath, backupPath)
    printInfo(`Backed up existing config to ${backupPath}`)
  }

  fs.writeFileSync(configPath, configContent)
  printSuccess(`Created session config at ${configPath}`)

  // Optionally initialize database
  if (args.db) {
    printInfo('Initializing database...')
    try {
      execSync('bash scripts/init-database.sh', { stdio: 'inherit' })
      printSuccess('Database initialized')
    } catch (error) {
      printWarning('Database initialization failed. You can run it manually with: pnpm db:init')
    }
  }

  // Print environment variables for CI/CD
  console.log('')
  printSuccess('Session created successfully!')
  console.log('')
  console.log('Environment variables for CI/CD:')
  console.log('')
  console.log(`  SESSION_ID=${sessionId}`)
  console.log(`  SESSION_NAME="${args.name}"`)
  if (args.description) {
    console.log(`  SESSION_DESCRIPTION="${args.description}"`)
  }
  console.log(`  PRESENTATION_TITLE="${args.name}"`)
  console.log('')
  console.log('To deploy with this session:')
  console.log(`  pnpm deploy`)
  console.log('')
}

main().catch((error) => {
  printError(error.message)
  process.exit(1)
})
